# Модем относительной фазовой модуляции
Реализован [модулятор и демодулятор](https://zvondozvon.ru/radiosvyaz/modulyator-demodulyator?ysclid=lpgsgktzqn951514591) сигналов
с [относительной фазовой модуляцией](https://vunivere.ru/work63579/page2) (ОФМ) для позиционностей, являющихся степенью двойки.
Сигнальное созвездие заполняется в соответствии с [кодом Грея](https://zvondozvon.ru/radiosvyaz/kod-greya?ysclid=lpgoc3vcky544727201).

РИСУНКИ СОЗВЕЗДИЙ

* Решена проблема дублирования кода, связанная с реализацией каждой конкретной позиционности ОФМ.
* Решена проблема некратности несущей частоты ($`Fc`$) частоте дискретизации ($`Fs`$).

Последняя проблема заключалась в том, что в одном периоде элементарного сигнала (символа) укладывалось нецелое количество отсчетов,
определяемое как $`Fs/Fc`$. Для решения использованы:

1. на передающей стороне - сигнал, [сопряженный по Гильберту](https://leonidov.su/ru/hilbert-transform-lection-notes/) к информационному,
$`Fc`$ которого определяется автоматически как ближайшее к заданной несущей частоте значение, делящее без остатка $`Fs`$;
2. на приёмной стороне - [синфазно-квадратурная](https://radioprog.ru/post/415?ysclid=lpgrirfca323143642) демодуляция и матрица 
[декорреляции](https://en.wikipedia.org/wiki/Decorrelation).

Таким образом, модулированный символ может содержать нецелое число периодов гармонического колебания. При этом **главным требованием к работе
модема является кратность частоты дискретизации символьной скорости**. В дальнейшем эта проблема также может быть решена путём "накопления"
символов на приёмной стороне до тех пор, пока имеющееся количество отсчетов не станет кратно символьной скорости. После чего демодуляция
будет осуществляться поблочно, работая с расширенным алфавитом.


## Параметры сигнала
Базовым классом к модулятору и демодулятору является `SignalParameters`, который содержит необходимые методы установления и получения значений
параметров, нужных пользователю.

### Поля класса
Все поля являются `protected` для взаимодействия с ними в классах-наследниках.

1. `uint16_t positionality_` - позиционность ОФМ;
2. `double amplitude_` - амплитуда колебания в Вольтах. По умолчанию устанавливается равной единице;
3. `double phase_` - текущее значение фазы в радианах;
4. `double phase_shift_` - значение дополннительного фазового сдвига в радианах;
5. `uint32_t symbol_speed_` - символьная скорость, определяется как количество, символов передаваемое за секунду [символов/с];
6. `uint32_t carrier_frequency_` - несущая частота в Герцах;
7. `double carrier_cyclic_frequency_` - циклическая несущая частота в радианах;
8. `uint32_t sampling_frequency_` - частота дискретизации в Герцах;
9. `double time_step_between_samples_` - шаг дискретизации во временной области в секундах.

### Методы класса
Все методы класса являются `public` и имеют константную сложность, т.е. выполняются за $`О(1)`$ по времени и по памяти.

1. `SignalParameters` - конструктор, принимающий значения частоты дискретизации и символьной скорости. Для этих двух параметров не существует
сеттеров, поэтому в случае необходимости их изменения требуется создание нового объекта;
2. `SetPositionality` - установить позиционность модуляции. Является виртуальным и переопределяется в модуляторе и демодуляторе в соответствии
со спецификой этих классов;
3. `GetPositionality` - получить текущее количество позиций фаз;
4. `SetAmplitude` - установить значение амплитуды сигнала;
5. `GetAmplitude` - получить значение амплитуды сигнала;
6. `SetPhase` - установить текущее значение фазы. Позволяет сдвинуть сигнальное созвездие на заданный в **радианах** угол. Значение со знаком
"+" - сдвиг по против часовой стрелки, со знаком "-" - по часовой стрелке;
7. `GetPhase` - получить текущее значение фазы;
8. `SetCarrierFrequency` - установить значение несущей частоты. Является виртуальным и переопределяется только в демодуляторе;
9. `GetCarrierFrequency` - получить значение несущей частоты;
10. `GetSamplingFrequency` - получить значение частоты дискретизации;
11. `GetSymbolSpeed`- получить значение символьной скорости;
12. `SetPhaseShift` - установить значение дополнительного фазового сдвига в **радианах**. Является виртуальным и переопределяется в модуляторе и
демодуляторе в соответствии со спецификой этих классов;
13. `GetPhaseShift` - получить значение дополнительного фазового сдвига в **радианах**.


## Модулятор
Публично наследуется от класса `SignalParameters`. Главный функционал реализован в методе `Modulation`, который принимает на вход последовательность
бит `std::vector<bool>`, надлежащую модуляции и флаг `PresencePivotSymbol`, который позволяет учесть наличие/отсутствие опорного символа в этой
последовательности. Внутри данного метода автоматически определяется схема модуляции:
1. классическая, когда $`Fs`$ кратна $`Fc`$;
2. с использованием промежуточной частоты, когда $`Fs`$ **не** кратна $`Fc`$.

  То есть пользователю не нужно принимать участия в выборе нужной схемы модуляции. Ему достаточно указать необходимые параметры сигнала до начала
сеанса связи. Если количество бит не кратно установленной позиционности, то дописываются нулевые биты до ближайшей степени двойки.

  Сложность данного метода $`O(N)`$ - если опорный символ содержится в последовательности бит и $`O(2*N)`$ - если опорный символ **не** 
содержится в последовательности бит и его нужно добавить в начало.

  Метод возвращает последовательность отсчетов `std::vector<double>`. Также существует перегрузка данного метода с указанием требуемой
позиционности. Перегрузка содержит в себе обработку установления нового значения позиционности с последующим вызовом перегрузки, принимающей
последовательность бит и флаг о наличии/отсутствии опорного символа.

### Поля класса
1. `uint32_t intermediate_frequency_` - промежуточная частота в Герцах;
2. `double intermediate_cyclic_frequency_` - циклическая промежуточная частота в радианах;
3. `std::map<uint16_t, double>  phase_shifts_` - словарь, в котором ключи - символы, а значения - соответствующие им фазовые сдвиги в **радианах**;
4. `std::function<double(double)> mod_function_` - модулирующая функция. По умолчанию устанавливается $`sin`$;
5. `std::function<double(double)> ortogonal_mod_function_` - функция, ортогональная модулирующей. По умолчанию устанавливается $`cos`$.

### Остальные методы класса
#### public
1. `DPSKModulator` - конструктор, принимающий значения частоты дискретизации, символьной скорости и позиционность. Для первых двух параметров не
существует методов их установления, поэтому в случае необходимости их изменения требуется создание нового объекта. По умолчанию позиционность
задаётся равной 2. Сложность: $`O(2 * positionality * log2(positionality))`$;
2. `SetPositionality` - установить позиционность модуляции. Переопределяется в данном классе т.к. после изменения позиционности ОФМ необходимо
заполнить словарь `phase_shifts_` актуальными значениями. Сложность: $`O(2 * positionality * log2(positionality))`$;
3. `SetModulationFunction` - установить модулирующую и ортогональную ей функции: $`cos`$ или $`sin`$. Сложность: $`O(1)`$;
4. `GetPhaseShifts` - получить константную ссылку на словарь символов с соответствующими сдвигами по фазе `phase_shifts_`. Сложность: $`O(1)`$;
5. `SetPhaseShift` - установить значение дополнительного фазового сдвига в **радианах**. Переопределяется в данном классе т.к. после изменения
дополнительного сдвига по фазе требуется заполнить словарь `phase_shifts_` актуальными значениями. Сложность: $`O(positionality)`$;
6. `SetIntermediateFrequency` - установить значение промежуточной частоты в случае $`Fs`$ некратности $`Fc`$. Сложность: $`O(1)`$;
7. `GetIntermediateFrequency` - получить значение промежуточной частоты. Сложность: $`O(1)`$;
8. `ModulationOneSymbol` - модуляция одного символа. Сложность: $`O(sampling frequency / carrier frequency)`$.

#### private
1. `FillPhaseShifts` - заполнить словарь `phase_shifts_` со значениями сдвигов фаз. Используется генератор кодов Грея, реализованный в виде функции
`gray_code::MakeGrayCodes`. Сложность: $`O(positionality)`$;
2. `ClassicalModulation` - модуляция без изпользования промежуточной частоты. Частота дискретизации кратна несущей частоте. Сложность: $`O(N)`$;
3. `ModulationWithUseIntermediateFreq` - модуляция с изпользованием промежуточной частоты. Частота дискретизации **не** кратна несущей частоте.
Сложность: $`O(N)`$.

## Демодулятор

## Системные требования
* GCC 6.3.0
* C++ 14
* CMake 3.5
